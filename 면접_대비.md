# 가장 좋아하는 게임

고스트 오브 쓰시마 를 가장 좋아합니다. 고스트 오브 쓰시마는 캐릭터의 기본 움직임이 한 걸음 마다 충실하게 적용되어 있습니다. 사용자의 입력에 따른 자연스러움 동작의 이어짐과 각 동작이 지면과의 어긋남 없이 발자국을 남기며 이어지는 전투는 몰입감을 극대화 시켜줍니다. 저는 고스트 오브 쓰시마를 플레이하고 가장 실감나는 전투를 경험했습니다. 이러한 캐릭터와 주변 객체의 상호작용이 저를 개발자의 길로 이끌었고 그런 기술을 구현하기 위한 공부의 원동력이 되었습니다.
# c++

- - 객체 지향 프로그래밍은 무엇인가?

객체 지향 프로그래밍은 데이터를 포함하는 객체 간의 상호작용을 중심으로 프로그램을 설계하는 방식입니다.
객체를 사용함하는 것으로 캡슐화, 상속, 다형성, 추상화 와 같은 개념을 사용할 수 있습니다.
캡슐화란 접근 제한자를 활용하여 객체의 데이터에 대한 노출 정도를 제어할 수 있는 것입니다. 이를 통해 객체의 데이터를 보호할 수 있습니다.
상속은 베이스 클래스의 속성과 기능을 새로운 derived class 에서 재사용하고 확장할 수 있도록 하는 개념입니다. 이는 코드 재사용과 유지보수를 용이하게 합니다.
다형성이란 오버로딩, 오버라이딩, 템프릿, 인터페이스, 함수 포인터 와 같은 기법을 활용하여 같은 이름의 메서드나 연산자가 객체의 타입이나 실행 환경에 따라서 다르게 동작할 수 있도록 하는 개념입니다.
추상화란 객체의 공통된 속성을 묶어서 다루는 것을 말합니다. 추상클래스와 인터페이스를 사용하여 공통된 특정을 정의하도록 합니다.

- C++ 의 빌드 과정을 설명해라

전처리 단계에서 전처리 지시문을 실행합니다. 이에 따라 소스파일이 처리됩니다. 컴파일 단계에서 전처리된 소스 코드를 컴파일러에 의해 기계어로 번환되고 오브젝트 파일이 됩니다. 링킹 단계에서 생성된 오브젝트를 링커가 하나의 실행파일로 결합합니다. 링커는 오브젝트 파일간의 의존성을 해결하고 필요한 라이브러리 코드를 포함시켜 최종 실행 파일을 생성합니다. 

- C 는 어떤 언어이고 C++ 과 차이점은 무엇인가.

C 는 절차 지향적 언어이고 C++ 은 절차 지향 뿐 아니라, 객체 지향, 템플릿 함수형 프로그래밍 등을 지원합니다.
C++ 이 객체 지향은 결국 데이터의 추상화 이고 이 추상화는 가상 함수 테이블과 같은 추가적인 메모리 구조가 필요하기 때문에 C 보다 메모리를 더 사용합니다. 따라서 메모리 제어가 중요한 OS 개발, 임베디드 시스템 개발은 C 를 사용하고 게임 엔진 개발, GUI 프레임 워크개발은 C++ 를 사용하는 것이 적합합니다.
C 는 구조체와 함수 포인터를 활용해 데이터를 묶어서 사용할 수는 있지만 상속, 다형성, 캡슐화 등의 객체 지향 프로그래밍의 개념을 편하게 사용할 수는 없습니다.
C 는 표준 라이브버리의 기본적인 함수들을 활용하지만 C++ 은 표준라이브러리를 포함하여 STL 을 추가로 사용할 수 있습니다.
C 는 메모리를 수동으로 관리하지만, C++ 은 스마트 포인터를 지원하여 자동으로 메모리를 관리할 수 있습니다.
C 는 템플릿을 지원하지 않아서 매크로를 주로 사용하지만 C++ 은 템플릿을 지원하여 타입에 구애받지 않은 코드를 작성할 수 있습니다.
C 에서 입출력은 서식지정자를 정해주어야 하지만 C++ 에서는 그렇지 않습니다. 
C 에서는 함수 오버로딩을 지원하지 않아서 같은 이름의 함수를 중복해서 사용할 수 없지만 C++ 은 인자 리스트만 다르다면 같은 이름의 함수를 사용할 수 있습니다.
C 에서는 namespace 기능이 없어서 전역변수와 함수를 사용할 때 이름의 충돌 위험이 있지만 C++ 은 namespace 를 지원합니다.

- C와 C++ 의 동적 할당의 차이점은 무엇인가.

C 는 malloc 과 free 를, C++ 은 new 와 delete 를 사용합니다. malloc 은 new 에 비해 타입 지정과 생성자 및 소멸자가 없습니다. 따라서 malloc 으로 할당하면 멤버 변수가 초기화 되지 않고 단순한 메모리 블록 할당만 진행합니다.

- 포인터란 무엇인가.

포인터는 메모리 블록의 주소를 저장하는 변수입니다. 포인터를 통해서 메모리의 주소를 직접 다룰 수 있고 이를 통해 동적 메모리 할당, 배열, 함수 호출 등을 할 수 있습니다. 

- 스마트 포인터란 무엇인가.

new 로 동적 할당 받은 객체는 delete 로 해제해 주어야 합니다. 이를 자동으로 해주는 것을 스마트 포인터라고 합니다.
스마트 포인터에는 unique_ptr, shared_ptr, weak_ptr 이 있습니다.
unique_ptr 은 하나의 주소를 가리킵니다. 복사가 불가능하지만 move() 로 이동은 가능합니다.
shared_ptr 은 하나의 주소를 공유합니다. 참조 횟수를 통해 몇 개의 shared_ptr 이 주소를 가리키는지 확인하고 참조 횟수가 0 이 되면 해당 메모리를 해제합니다. 이 참조 횟수는 Garbage collector 에서 관리합니다.
weak_ptr은 shared_ptr 이 가리키는 주소를 참조하지만 참조 횟수를 증가시키지는 않습니다.

- 가상 함수는 어떻게 동작하는가.

virtual 키워드가 붙어서 가상함수가 되면 해당 가상 함수를 가진 클래스는 vtable을 생성하고 vtable을 에 가상함수를 저장합니다. 그리고 해당 가상함수가 어디에서 재정의 되는지 확인하고 호출시에 virtual table 에 기록된 것을 바탕으로 적절한 함수를 호출합니다.

- 얕은 복사와 깊은 복사의 차이는 무엇인가.

얕은 복사는 복사본과 원본이 같은 주소를 공유하고 깊은 복사는 복사본과 원본이 다른 주소를 가리키지만 값은 같습니다.

- 포인터와 배열의 차이는 무엇인가. 

둘 다 변수 자체는 메모리 주소를 뜻하지만 배열은 선언과 동시에 주어진 크기만큼 연속적인 메모리 공간을 가집니다.
따라서 포인터는 대입이 가능하지만 배열은 포인터 상수여서 다른 주소를 가리킬 수 없습니다. 따라서 포인터 변수는 증감 연산자가 가능하지만 배열은 상수이므로 사용이 불가능 합니다. 이 때문에 배열 내에서 요소를 순서 대로 가리키기 위해서는 iterator 와 증감연산자를 사용합니다.

- rvalue 와 lvalue 의 차이는 무엇인가. 

rvalue 는 일시적으로 존재하여 주소가 없는 값입니다. 따라서 변수가 될 수 없습니다. lvalue 는 주소를 갖을 수 있어 변수가 될 수 있습니다.

- 정적 바인딩과 동적 바인딩의 차이는 무엇인가
정적 바인딩은 컴파일 타임에 결정되는 바인딩 입니다. 함수 호출을 컴파일러가 미리 결정하기 때문에 실행 속도가 빠릅니다.
동적 바인딩은 런타임에 결정되는 바인딩으로 대표적으로 가상함수에서 발생합니다. 타입을 체크해야 하기 때문인데 이에 수행 속도 저하가 발생할 수 있습니다. 

- 상속과 생성자 및 소멸자의 관계를 설명하라

부모 생성자 자식 생성자 자식 소멸자 부모 소멸자 순으로 호출됩니다. 이때 부모 소멸자가 virtual 이 아니라면 자식 소멸자는 호출되지 않습니다.

- 복사 생성자란 무엇인가.

다른 객체로부터 값을 복사해서 새로운 객체를 초기화 하는 것을 말합니다. 사용자 정의하지 않으면 컴파일러가 자동으로 만듭니다. 컴파일러가 만든 복사 생성자는 얕은 복사를 수행합니다.

- static_cast 와 dynamic_cast 의 차이는 무엇인가.

static_cast 는 컴파일 단계에서 변환이 수행됩니다. 업 케스팅은 자동으로 이루어지지만 다운캐스팅은 명시적으로 해주어야 한다.
dynamic_cast 는 런타임 단계에서 변환이 수행됩니다. 가상 함수는 dynamic_cast 로 해주어야 합니다.

- static 의 활용에 대해 설명하라

함수 내에서 static 으로 변수가 선언 되면 선언된 변수는 지역 변수이나 함수가 호출될 때마다 초기화 되지 않고 프로그램 종료 때까지 값을 유지 됩니다.
클래스 내에서 static 으로 선언 되면 해당 멤버는 인스턴스와 독립적으로 존재합니다. 즉, 클래스를 기반으로 생성된 인스턴드 간에 해당 맴버 값을 공유하며 클래스 이름으로 직접 접근할 수 있습니다.
전역 변수 또는 전역 함수을 static 으로 선언하면 해당 변수나 함수가 선언된 파일 내에서만 유효하여 다른 파일에서 접근할 수 없습니다.

STL

- array, vector, list, deque 의 정의와 차이를 설명하라.

array 는 정적 배열이고 나머지는 동적 배열입니다.
vector 는 메모리가 연속적으로 할당되며 마지막 인덱스에 대한 접근에 효율적입니다.
list 는 이중 연결 리스트로 메모리가 비연속적이며 요소의 삽입 삭제가 빠르지만 각 요소가 이전 및 다음 요소에 대한 포인터를 가지고 있어 메모리 오버헤드가 큽니다.
deque 는 양쪽 끝에서 빠르게 삽입 및 삭제가 가능한 컨테이너이며 메모리가 연속적이지 않습니다.

- map 과 set 을 설명하라

map 은 key - value 쌍을, set 은 key 만을 요소로 갖습니다. map 과 set 모두 key 를 기준으로 정렬하며 각 key 는 고유합니다. 레드 블랙 트리로 정렬 됩니다.

- unordered_map 과 unordered_set 을 설명하라

unordered_map 과 unordred_set 은 기존 map 과 set 에 비해 정렬 기능이 없습니다. 대신 해시 테이블을 사용하여 빠른 삽입과 검색이 가능합니다.

- multimap 과 multiset 을 설명하라

multimap과 multiset 은 기존 map 과 set 에 비해 key 값의 중복을 허용합니다.

- 해시 테이블은 무엇인가.

key 와 value 를 해시 함수를 이용해 연결하는 방식입니다.
key 를 해시 함수를 통해 해시 값으로 변환하고 해시 값은 배열의 인덱스로 사용됩니다. 해당 배열의 인덱스에 값을 저장합니다.
두 개 이상의 key 가 값은 값을 가지는 경우 충돌이 발생하는데 이를 체이닝, 개방 주소법 등으로 해결합니다.

- stack과 queue 는 무엇인가.

둘 다 배열이지만 stack 은 후입 선출, queue 는 선입 선출의 구조 입니다. stack 은 top() 함수로 마지막 인덱스의 데이터를 확인하고 queue 는 front() 함수로 첫 번째 인덱스의 데이터를 확인합니다.

- priority_queue (우선 순위 큐) 는 무엇인가.

priority_queue 는 삽입된 요소들에 우선순위를 두고 요소를 처리합니다. 기본적으로는 가장 큰 값을 요소를 최우선 취급합니다. 즉 top() 이 가장 큰요소를 반환 하게 됩니다.

- 순열 이란 무엇인가.

순열은 정해진 원소들 중 순서를 고려하여 선택한 원소들의 나열을 말합니다.
next_permutation 은 사전순으로 다음 순열을 반환하고, prev_permutation 은 사전순으로 이전 순열을 반환합니다.
두 함수를 사용하기 위해서는 배열이 정렬된 상태여야 합니다.

- 버블 정렬, 선택 정렬, 삽입 정렬, 퀵 정렬은 무엇인가

버블 정렬은 인접한 두 요소를 반복 순회하며 비교하여 정렬하는 방법입니다.
선택 정렬은 한번에 모든 요소를 순회하며 가장 적합한 요소를 골라 정해진 인덱스에 두는 방법입니다.
삽입 정렬은 정렬된 부분을 정하고 나머지 요소를 정렬된 부분과 비교하여 정렬된 부분사이의 적절한 자리에 위치시키는 방법입니다.
퀵 정렬은 pivot 을 설정하여 pivot 기준으로 크고 작음 을 따져 요소를 이동시키는 방법입니다.

- UObject 와 Actor 를 설명하라

UObject 는 언리얼 엔진의 모든 객체의 베이스 클래스 입니다. UObject 를 상속 받는 클래스에 UCLASS 매크로를 태그하면 해당 클래스는 Garbage Collection, Reflection, Serialization 등의 핵심 기능을 지원합니다.

- Unreal 의 GarbageCollector 를 설명하라
Garbage Collection 은 UObject 기반의 객체의 생명 주기를 관리합니다. 각 객체의 참조 관계를 추적하여 사용되지 않는 객체를 자동으로 제거합니다. GC 에 의해 관리 대상이 되기 위해서는 UCLASS() 로 선언되어야 하고 GC 가 추적하려면 객체가 UPROPERTY() 로 선언된 변수이거나 TArray<UPROPERTY()>와 같이 GC 에서 관리하는 컨테이너여야 합니다.

- GameFramework 에 대해 설명하라.

게임이 실행되면 다음의 순서대로 생성자를 호출한다. GameInstance -> GameMode -> GameState -> PlayerController -> Player State -> Player(pawn). 이 다음으로 로드한 Level 의 BeginPlay 가 호출된다.

- GameInstance 는 무엇인가.

게임이 시작되고 종료될 때까지 레벨이 변경되어도 지속되는 객체로 게임의 전체적인 생명주기를 관리하고 설정, 네트워크 상태, 로비정보 등의 게임 간의 전역 데이터나 게임 상태를 유지한다.

- GameMode 는 무엇인가

각 레벨에 대해 하나의 인스턴스가 존재하며, 해당 레벨의 규칙을 관리한다.

- GameState 는 무엇인가

게임의 진행상황에 대한 데이터를 관리.

- Player Controller 가 멀티 환경과 로컬 환경에서 어떻게 다르게 작용하는가.

로컬 환경에서 Player Controller 는 Input Action, Input Mapping context 를 관리하고 입력에 영향을 받는 UI 또한 관리합니다.
멀티 환경에서 Player controller 는 입력처리 뿐 아니라 입력 데이터를 서버로 전송합니다. 서버는 전달받은 입력 데이터로 캐릭터의 움직임을 계산하고 이를 다른 모든 클라이언트에게 전달하여 게임의 상태를 동기화 합니다.




### 기타
- NULL 과 nullptr 차이
	- NULL 은 0으로 치환되어 상수로 취급. nullptr 은 포인터 취급.

- inline 함수
	- 코드가 호출된 위치에 직접 삽입되는 함수. 함수 호출이 아니라서 속도가 증가함. 
	- 하지만 inline 을 많이 사용하면 실행 파일 크기(바이너리 크기) 가 커지고 캐시 효율이 낮아져서 성능이 저하된다.
	- 디버거에서 함수 호출단계를 볼 수 없다.

- 가상함수 동작 원리
	- 가상 함수가 있는 클래스는 가상 테이블(vtable) 을 갖느다.
	- vtable은 해당 클래스의 가상함수들의 주소를 저장한 테이블
	- 객체는 vtable 을 참조하여 적절한 함수의 주소를 호출
- c++ 빌드 과정
	- 소스 코드 작성 -> 전처리(# 로 시작하는 전처리기 구문 처리) -> 컴파일(고수준 언어를 어셈블리어로 번역) -> 어셈블(어셈블리 파일을 오브젝트 파일로 만들고 오브젝트 파일들을 합한다.) -> 링크(라이브러리와 연결) -> 실행(실행파일 생성.) 순서
- 복사
	- 얕은 복사
		- 객체의 메모리 주소만 복사하여 원본과 복사본이 같은 메모리 공간 공유
	- 깊은 복사
		- 객체를 복사할 때 새로운 메모리를 할당하여 원본과 독립적인 복사본 생성.
- 포인터와 배열 차이
	- 둘다 변수 자체는 메모리 주소를 뜻하지만 배열은 변수 선언과 동시에 주어진 크기만큼의 연속적인 공간을 가진다.
	- 배열은 포인터 상수여서 다른 주소를 가리킬 수 없고 포인터는 변수이므로 대입이 가능.
	- 포인터 변수는 증감 연산자가 가능이지만 배열은 상수이므로 사용 불가능.
- 정적 바인딩과 동적 바인딩.
	- 바인딩 : 변수나 함수 호출을 실제 메모리 상의 주소 또는 실행 코드와 연결하는 과정.
	- 정적 바인딩 : 컴파일 타임에 결정 되는 바인딩. 함수 호출을 컴파일러가 미리 결정. 실행 속도 빠름
	- 동적 바인딩 : 런타임에 결정되는 바인딩, virtual 키워드를 사용한 가상함수에서 발생. 타입 체크로 수행 속도 저하 발생 가능.
- rvalue와 lvalue 차이
	- lvalue : 메모리에 존재하며, 주소를 가질 수 있는 값.
	- rvalue : 일시적으로 존재하며 주소가 없는 값.
	- lvalue 는 변수가 될 수 있지만, rvalue 는 변수가 될 수 없다.
- cast
	- static_cast
		- 컴파일 단계에서 수행되는 변환, 명시적 변환으로 안전환 타입 변환을 제공, 업케스팅 가능, 다운캐스팅은 가능하나 안전하지 않음.
	- dynamic_cast
		- 런타임에 타입변환을 수행
		- 업캐스팅, 다운캐스팅 가능.
		- 다형성을 지원하는 클래스에서 사용해야함, 다운캐스팅 실패 시 nullptr 반환.
- 자식 클래스 소멸자
	- 부모 클래스 타입에 변수를 할당하였다고 가정할 때 소멸시 부모 클래스의 소멸자는 호출되지만 자식 클래스의 소멸자는 호출되지 않는다. 이는 부모 클래스의 소멸자를 virtual 로 선언하여 해결한다.
- 복사 생성자
	- 다른 객체로부터 값을 복사해서 새로운 객체를 초기화. 정의하지 않으면 컴파일러가 자동으로 만든다. 기본적으로 자신과 동일한 타입의 객체에 대한 레퍼런스(&)를 인자로 받는 생성자.
- 얕은 복사와 깊은 복사
	- 얕은 복사는 원본과 복사본이 가리키는 메모리 주소가 같고, 깊은 복사는 원본가 복사본이 가리키는 메모리 주소가 다르면서 값은 같다.
- 템플릿
	- 자료형을 일반화 하여 다양한타입에 대해 재사용할 수 있도록 한다.
- constexpr (Constant Expression)
	- 컴파일 타임에 값을 결정할 수 있도록 하는 키워드.
	- constexpr 로 선언된 변수는 컴파일 타임에 계산되어야 한다.
	- 실행 중에 변경 불가.
	- constexpr 함수는 컴파일 타임에 계산될 수 있는 경우 미리 계산된다. -> 성능 향상.
	- constexpr 변수는 컴파일 타임에 계산되어야 한다.
	- constexpr 과 const 차이

|              | constexpr | const |
| ------------ | --------- | ----- |
| 컴파일 타임 상수 보장 | O         | X     |
| 함수에 사용 가능    | O         | X     |
| 값을 변경        | X         | X     |


# STL

- vector
	- 동적 배열
	- capacity() :현재 할당된 메모리 크기
	- reserve(n) : 메모리 재할당. 현재 capacity보다 크면 새로운 메모리를 할당하고 기존 요소를 복사
	- clear() 모든 원소 제거
	- insert(iterator, value)
	- erase(iterator)
- List
	- 이중 링크드 리스트
	- 앞 / 뒤 자유롭게 탐색 가능, 중간 삽입 및 삭제가 효율적.
	- 메모리가 비연속적 -> 랜덤 접근 느림
- Deque
	- 양 방향으로 동적 배열처럼 동작
	- 양쪽 끝에서의 삽입/ 삭제 빠름
- 반복자
	- reverse_iterator 역방향 반복자
		- rbegin(), rend()
	- const_iterator 상수 반복자.
	- back_inserter(), front_inserter(), inserter(원하는 위치에 삽입)  삽입 반복자.

- 알고리즘
	- 정렬
		- sort
		- partial_sort
		- stable_sort
		- nth_element
	- 탐색
		- find
		- binary_search
		- lower_bound
		- upper_bound
	- 수치
		- accumulate
		- inner_product
		- adjacent_difference
	- 수정
		- fill
		- replace
		- remove_if
		- unique

- map
	- key, value 쌍을 저장. 키를 통해 빠르게 value 를 탐색.
	- key는 유일.

- set
	- key 만 저장하고 중복을 허용 x
	- lower_bound(value) : 지정된 값 이상의 첫 번째 요소 반환
	- upper_bound(value) : 지정된 값 보다 큰 첫 번재 요소 반환

- multimap
	- 중복 허용 map

- multiset
	- 중복 허용 set

- priority_queue (우선순위 큐)
	- Heap 자료구조 사용.
	- 가장 큰 / 작은 원소를 순식간에 추출하는 문제에 최적화.
	- 가장 우선 == 값이 크다.
	- priority_queue<int, vector\<int>, greater\<int>> 최소 힙

- 순열
	- next_permutation : 주어진 범위를 사전순으로 다음 순열 반환.
	- prev_permutation : 주어진 범위를 사전 순으로 이전 순열 반환.
	- 위의 둘 모두 배열이 정렬된 상태여야한다.
	- nth_element : n 번째로 작은 원소를 찾고 그 원소가 있어야할 위치로 이동.

- 정렬
	- 버블 (앞 뒤로 계속 비교)
	- 선택 (전체적으로 보면서 그 상황에 가장 작은걸 찾는다)
	- 삽입 (하나의 원소를 두고 앞으로 가면서 들어가야할 자리를 찾고 서로 바꿈)
	- 퀵 (pivot 설정 후 pivot 기준으로 크고 작음을 따져 이동)

- 해시테이블
	- 해시 함수를 통해 키를 해시 값(인덱스) 으로 변환
	- 해시 값으로 배열에 접근.
	- 해시함수 기법
		- 나눗셈법
		- 곱셈법
		- 문자열 해싱
	- 충돌 처리 기법
		- 체이닝
			- 링크드 리스트를 활용하여 같은 인덱스에 여러 개의 데이터를 저장하는 방식
		- 개방 주소법
			- 해시 테이블 내에서 충돌한 데이터를 새로운 위치에 저장.
	- unordered_map
		- 중복을 허용하지 않는 유일한 값들의 집합 정렬하지 않는다.
	- unordered_set
		- 각 key 는 유일해야 한다. 정렬하지 않는다.
	- map, set 과 unordered_map, unordered_set는 내부구조 차이(레드 블랙 트리 vs 해시 테이블), 정렬 유무 (정렬이 필요한가 vs 빠른 검색이 필요한가.)

- 브루트 포스
	- 전체를 다 확인
- 백트래킹
	- 브루트 포스 중 가지치기를 추가. -> 시간 절약
	- 대부분 재귀함수를 통해 구현



https://strawvery-devlog.tistory.com/7



# 질문 리스트

- 객체 지향 프로그래밍은 무엇인가?
- C++ 의 빌드 과정을 설명해라
- - C 는 어떤 언어이고 C++ 과 차이점은 무엇인가.
- - C와 C++ 의 동적 할당의 차이점은 무엇인가.
- 포인터란 무엇인가.
- 스마트 포인터란 무엇인가.
- 가상 함수는 어떻게 동작하는가.
- 얕은 복사와 깊은 복사의 차이는 무엇인가.
- 포인터와 배열의 차이는 무엇인가. 
- rvalue 와 lvalue 의 차이는 무엇인가.
- 정적 바인딩과 동적 바인딩의 차이는 무엇인가
- 상속과 생성자 및 소멸자의 관계를 설명하라
- 복사 생성자란 무엇인가.
- static_cast 와 dynamic_cast 의 차이는 무엇인가.
- static 의 활용에 대해 설명하라
- array, vector, list, deque 의 정의와 차이를 설명하라.
- map 과 set 을 설명하라
- unordered_map 과 unordered_set 을 설명하라
- multimap 과 multiset 을 설명하라
- 해시 테이블은 무엇인가.
- stack과 queue 는 무엇인가.
- priority_queue (우선 순위 큐) 는 무엇인가.
- 순열 이란 무엇인가.
- 버블 정렬, 선택 정렬, 삽입 정렬, 퀵 정렬은 무엇인가
- UObject 와 Actor 를 설명하라
- Unreal 의 GarbageCollector 를 설명하라
- GameFramework 에 대해 설명하라.
- GameInstance 는 무엇인가.
- GameMode 는 무엇인가
- GameState 는 무엇인가
- Player Controller 가 멀티 환경과 로컬 환경에서 어떻게 다르게 작용하는가.


- TSubclassOf 와 TObjectPtr 의 차이는 무엇인가.
- 