# Main parts of GAS

'Ability System Component' is Component that can be added to an actor
and it handles lots of important things in the gameplay ability system, such as Granting abilities, activating those avilities, handling noritications for when certain abilities are activated or effects are applied.

We store a number of attrucutes on the 'Attribute Set', witch has a number of capabilities that allow us to associate those attributes with other various parts of the gas system.

'Gameplay ability' is class that we use to encapsulate the functionality of some sort of thing that a character or object can do in the game.
And the gameplay ability allows us to keep all the code and functionality kept inside of a specific gameplay ability class. 

Gameplay Ability run asynchronous tasks that we call 'Ability Tasks'.
Ability Tasks may perform its job and finish immediately or its job may span across a period of time and may do different things depending on what's going on in the game for that specific ability.

'Gameplay Effect' is what we use to change the values of attrubutes and they're capable of a number of different things related to attributes.
We use gameplay effects to change attrubutes directly, change them over time, periodically increase or decrease them, and associate those attributes changes with various calculations that takke other parameters and attributes into account.

'Gameplay Cue' is responsible for handling cosmetic effects such as partivle systems and sounds and can handle the replication of those as well.

'Gameplay Tag' is exist outside of gas and can be used in non gameplay ability system projects, but their use is pervasive all throughout gas and gameplay tags are extremely useful for identifying just about anything you can think of and their hierarchical nature makes the nore versatile than simple vatiables such as enums, booleans, or strings.

Ability System Component 와 Attribute Set 를 Pawn 에 추가하면 Pawn 이 destroy 될 때, Ability System Component 와 Attribute Set 도 삭제 되지만 Player State 는 그렇지 않다. 따라서 업적 과 같이 캐릭터가 죽더라고 기록되어야 하는 데이터가 있으므로 Player의 Ability System Component 와 Attribute Set 은 Player State 에 지정하고, Enemy AI 의 경우 Pawn 에 지정한다.

# Add AbilitySystemComponent and AttributeSet to SW_CharacterBase and SW_PlayerState

Add Player State (name SW_PlayerState)

in Player State's Constructor, Set 'NetUpdateFrequency' value to 100.f by calling 'SetNetUpdateFrequency(100.f);
NetUpdateFrequency is how often the server will try to update clients.
So as changes occur on the server for the player state, then the server will be sending updates out to all clients so that they can sync up with the server version. So any variables that should be replicated, they'll update and the server will try to meet this netupdatefrequency if it can.
Create Blurpint (name BP_PlayerState) that inherite SW_PlayerState. -> Set BP_PlayerState to BP_GameMode
Create C++ class (name SW_AbilitySystemComponent) that inherite AbilitySystemComponent
Create C++ class (name SW_AttributeSet) that inherite AttrubuteSet
Set Module Range in Build.cs
```c++
PrivateDependencyModuleNames.AddRange(new string[] { 
	"GameplayAbilities",
	"GameplayTags",
	"GameplayTasks"
});
```

Sending that data down to clients from server is called 'Replication'. Replication only works one way from server to client, so if a cariable is marked as replicared, it should not be changed on clients because the server will not know about that change and neither will any of the other clients. Client set data up to the server with RPC(Remote Procedure Call).

Declare 'SW_AbilitySystemComponent' and 'SW_AttributeSet' to 'SW_CharacterBase' and 'SW_PlayerState' -> Init 'SW_AbilitySystemComponent' and 'SW_AttributeSet' in 'SW_PlayerState's Constructor' and 'SW_CharacterAI's Constructor'.

Add Inheritance with 'IAbilitySystemInterface' to 'SW_CharacterBase' and 'SW_PlayerState' ->
Override and Implement the pure virtual function (called 'GetAbilitySystemComponent')

# Replication Mode

```c++
enum class EGameplayEffectReplicationMode : uint8
{
	// Only replicate minimal gameplay effect info. Note : this does not work for Owned AbilitySystemComponents (Use Mixed instead).
	Minimal,
	// Only replicate minimal gameplay effect info to simulated proxies but full info to owners and autonomous proxies
	Mixed,
	// Replicate full gameplay info to all
	Full
}
```
Setting that how gameplay effects sill be replicated to clients.


| Replication Mode | Use Case                       | Description                                                                                        |
| ---------------- | ------------------------------ | -------------------------------------------------------------------------------------------------- |
| Full             | Single Player                  | Gameplay Effects are replicated to all clients                                                     |
| Mixed            | Multiplayer, Player-Controlled | Gameplay Effects are replicated to the owning client only, Gameplay Tags replicated to all clients |
| Minimal          | Multiplery, AI_Controlled      | Gameplay Effects are not replicated. Gameplay Cues and Gameplay Tags replicated to all clients.    |


if change such as damage or heal player happens on the server, the client should know about it.

- Set Replication Mode
```c++
// SW_PlayerState
SW_PlayerState()
{
	...
	AbilitySystemComponent->SetReplicationMode(EGameplayEffectReplicationMode::Mixed);
}
```

```c++
// SW_CharacterAI
SW_PlayerState()
{
	...
	AbilitySystemComponent->SetReplicationMode(EGameplayEffectReplicationMode::Minimal);
}
```

# Set Owner Actor and Avatar Actor

The Ability System Component must be able to recognize its owenr.
In the case of AI, the owner of the Ability System Component is AI, but in the case of Player, the owner of the Ability System Component is Player State. However, in this case the owner of the player's Ability System Component should be the player. Therefore, we divide it into Owner Actor and Avator Actor to recognize the actual owned actor and the actor that expressed in the game world separately. These two values are set to the Ability System Component through 'InitAbilityActorInfo()'.

InitAbilityActorInfo 는 Possesion 이후에 호출되어야 한다. 즉, Controller 가 Pawn 에 설정된 이후여야 한다. 만약 Ability System Component 를 캐릭터에서 생성했다면 'PossessedBy' 함수에서 InitAbilityActorInfo 를 호출한다. 해당 함수에서 호출하면 Ability System component 를 서버에서 Owner Actor와 Avator Actor 값으로 초기화 할 수 있다. 하지만 PossessedBy 함수는 오직 서버에서만 호출된다. 클라이언트에서는 AcknowledgePossession 이라는 함수를 사용한다. 이 경우 Owner Actor 와 Avator Actor 모두 캐릭터 자신이 된다. 하지만 Ability System Component 를 Player State 에 생성한 경우 서버에서는PossessedBy 를 사용하고, 클라이언트에서는 OnRep_PlayerState 를 사용해야 한다. OnRep_PlayerState 는 RepNotify 함수이다. RepNotify 함수는 어떤 것이 Replication 된 결과로 호출되는 함수이다. 지금의 경우 Player State 가 Server 에서 설정되고 클라이언트로 복제되는데 이때 OnRep_PlayerState 가 호출된다. 이 시점에서는 클라이언트에서 Player State 가 클라이언트에 복제까지 마무리된 때이니 유효한 포인터가 되므로, 이때 Ability System Component 를 초기화 할 수 있다. 이 경우 Owenr Actor 는 Player State 가 되고  Avator Actor 는 Pawn  이다. AI 캐릭터의 경우 Ability System Component 가 AI 캐릭터 자체에 존재하기 때문에 BeginPlay() 에서 InitAbilityActorInfo() 를 호출하면 된다.

다시 말해 Player 클래스가 관여하는 AbilitySystemComponent 가 PlayerState 에 선언되어 있는 경우, InitAbilityActorInfo() 를 어디에서 호출해야 하는가에 대해. Server 의 경우 PossessedBy() 함수에서 호출하고, Client 의 경우 OnRep_PlayerState() 함수에서 호출한다.

SW_CharacterAI 의 경우 BeginPlay() 추가
```c++
// SW_CharacterAI
void ASW_CharacterAI::BeginPlay()
{
	Super::BeginPlay();

	AbilitySystemComponent->InitAbilityActorInfo(this, this);
}
```

SW_CharacterPlayer
```c++
// SW_CharacterPlayer.h
...
virtual void PossessedBy(AController* NewController) override;
virtual void OnRep_PlayerState() override;
void InitAbilityActorInfo();

// SW_CharacterPlayer.cpp
void ASW_CharacterPlayer::PossessedBy(AController* NewController)
{
	Super::PossessedBy(NewController);

	// Init ability actor info for server
	InitAbilityActorInfo();
}

void ASW_CharacterPlayer::OnRep_PlayerState()
{
	Super::OnRep_PlayerState();

	// Init ability actor info for client
	InitAbilityActorInfo();
}

void ASW_CharacterPlayer::InitAbilityActorInfo()
{
	ASW_PlayerState* PlayerState = GetPlayerState<ASW_PlayerState>();
	check(PlayerState);
	PlayerState->GetAbilitySystemComponent()->InitAbilityActorInfo(PlayerState, this);
	AbilitySystemComponent = PlayerState->GetAbilitySystemComponent();
	AttributeSet = PlayerState->GetAttributeSet();
}

```

- EGameplayEffectReplicationMode::Mixed and Owner Actor's Owner
Replication Mode 를 Mixed 로 설정할 경우, Owner Actor 의 Owner 는 반드시 Controller 여야 한다.
진행중인 프로젝트의 경우 Ability System Component 의 Owner Actor 는 PlayerState 이니 PlayerState 의 Owner 는 Controller 가 되어야한다. PlayerState 의 Owner 의 default 설정이 Controller 이기 때문에 따로 설정하지 않는다. Ability System Component 의 Owner Actor 가 Pawn 이라면, PossessedBy 함수에서 자동으로 Pawn 의 Owner 는 Controller 로 설정된다.
하지만 Owner Actor 가 PlayState 와 같이 default 값으로 controller 를 설정해 주는 것이 아니라면 SetOwner() 를 호출하여 Ability System Component 의 Owner Actor 의 Owner 를 Controller 로 수동 설정해주어야 한다.

# Attribute

Ability System Component 와 Attribute Set 을 Owner Actor 의 생성자 안에서 함께 생성하면 Attribute Set 은 자동으로 Ability System Component 에 등록된다. 이때 하나의 Ability System Component 는 여러개의 Attribute 를 가질 수 있지만 각 Attribute 의 Class 는 모두 달라야 한다. 같은 타입의 Attribute Set 이 Ability System Component 에 등록되면 해당 Attribute Set 를 가져올때 모호성 문제가 있기 때문이다.
Attribute 는 메모리를 거의 사용하지 않기 때문에 하나의 Attribute Set 클래스에 모든 내용을 다 넣어도 상관은 없다. 하지만 여러 개의 Attribute 를 사용하는 것 또한 가능하다는 것을 알아두자.

Attribute 란 캐릭터와 같은 게임의 Entity 의 속성값들의 Enum 이라고 할 수 있다. 모든 Attribute 는 float 형 이고 GamePlayAttributeData 라는 구조체 안에 존재한다.
Attribute 들은 Attribute Set 내부에 저장되고 Attribute Set 은 속한 Attribute 가 변경됨을 감지한다. 이 감지라는 반응을 이용하여 원하는 기능을 구현한다. 직접 attribute 값을 코드로 설정할 수 있지만 Gameplay Effect 를 통해 값을 변경하는 것이 바람직하다.

Gameplay Effect 를 사용하는 중요한 이유 중 하나는 'Prediction' 기능 때문이다.
Prediction 은 client 가 값을 바꾸라는  server 의 permission 을 기다리지 않고 client 단에서 즉시 값을 변경한다. 그리고 서버는 그 변경을 알린다. Server 는 변경이 유효하다면 그대로 유지하고, 그렇지 않다면 roll back 한다.

Prediction 기능이 없다면 플레이어가 조작한 결과를 서버의 응답이 오기 전까지 볼 수 없게 되고 이는 게임 플레이 경험의 질을 떨어뜨린다.

Prediction 이 없는 경우
1. Client 가 Attribute 의 값을 변경하려는 로직 실행.
2. Server 에 요청
3. Server 에서 조건 확인 후 유요하면 승인
4. Client 에 승인 전달.
5. Client 에서 실제로 값 변경.

Prediction 을 사용하는 경우
1. Gameplay Effect 가 Attribute 를 변경 -> Client 단에서 즉시 변경됨.
2. 서버에 변경 사항 전송
3. 서버가 유효성 검토
4. 유효하다면 다른 클라이언트에 공유
5. 무효하다면 roll back 처리.

Prediction 기능을 통해 Server authority 를 보장하면서 client 의 반응성을 보장할 수 있다.

Attribute 는 실제로 두 개의 값(Base Value, Current Value)을 가진다.
Base Value 는 해당 속성의 영구적인 값이고 Current Value 는 기본 값에 Gameplay Effect 에 의해 적용된 일시적인 수정값이다. 
예를 들어 어떤 버프작용을 받아서 값이 증가 했다가 일정 시간이 흐른 뒤 원래 값으로 돌아가는 것을 Base Value 와 Current Value 로 구현한다.

- Attribute 추가.
```c++
// SW_AttributeSet.h
UPROPERTY(ReplicatedUsing = OnRep_Health)
FGameplayAttributeData Heath;
```

ReplicatedUsing 키워드를 사용하여 해당 attribute 에 RepNotify 함수를 바인딩한다. Attribute 는 서버 단의 값 변경에 대한 Replicate 마다 반응한다. 이에 함수를 바인딩하여 해당 Attribute 가 변경될 때마다 바인딩된 함수가 호출되도록 한다.
해당 기능에서 언리얼은 함수명 어두로 OnRep_ 을 사용한다.

```c++
// SW_AttributeSet.h
UFUNCTION()
void OnRep_Health(const FGameplayAttributeData Old_Health);
```

```c++
// SW_AttributeSet.cpp
#include "AbilitySystemComponent.h"

void USW_AttributeSet::OnRep_Health(const FGameplayAttributeData& Old_Health)
{
	GAMEPLAYATTRIBUTE_REPNOTIFY(USW_AttributeSet, Health, Old_Health);
}
```

RefNotify 로 동작하기 위해서는 UFUNCTION() 매크로로 선언되어야 한다.
또한 인자는 1개 까지만 받을 수 있으며 아예 받지 않을 수 있다.
인자의 경우 그 타입은 FGameplayAttributeData 여야 한다. 
const 참조로 받을 수 있고 인자로 전달되는 값은 Old Value(Base Value) 이다.
AttributeSet 에서 RepNotify 를 설정할 때에는 Ability System 값이 변경되었음을 알리기 위해 GAMEPLAYATTRIBUTE_REPNOTIFY 매크로를 사용한다.

- Register Attribute

```c++
// SW_AttributeSet.h
virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutlifetimeProps) const override;
```

```c++
// SW_AttributeSet.cpp
void USW_AttributeSet::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);

	DOREPLIFETIME_CONDITION_NOTIFY(USW_AttributeSet, Health, COND_None, REPNOTIFY_Always);
}
```
Replicate 할 Attribute 를 GetLifetimeReplicatedProps() 함수를 통해 등록해야 한다.

```c++
DOREPLIFETIME_CONDITION_NOTIFY(ClassName, PropertyName, Condition, RepNotifyCondition);
```
DOREFLIFETIME_CONDITION_NOTIFY() 는 PropertyName 을 네트워크 Replication 대상으로 등록한다. 언제 Replicate 할지에 대한 조건인 Condition 과 OnRep_ 호출 조건인 RepnotifyCondition 르 설정한다.
- Condition
	- COND_None 의 경우 조건 없이 Replicate 한다.  
	- COND_Owneronly 의 경우 오직 소유자에게만 복제한다.
	- COND_SkipOwner 의 경우 소유자 제외하고 복제한다.
	- COND_SimulatedOnly 의 경우 시뮬레이션 클라이언트에만 복제한다.
	- ... etc
- RepNotifyCondition
	- REPNOTIFY_OnChanged : 값이 변경될 때만 OnRep_ 를 호출(default)
	- REPNOTIFY_Always : 값이 바뀌지 않아도 복제되면 항상 OnRep_ 호출
GAS 에서는 값이 바뀌지 않아도 설정 행위(setting itself; 변수의 값을 설정하려고 시도한 행위 자체. 실제고 값이 바뀌는 것과 상관없이 코드상에서 값을 세팅하려고 한 것. 예를 들어 이미 health 가 100 인데 100으로 설정하려는 시도에 반응해야 한다.)에 반응해야 하기 때문에 REPNOTIFY_Always 를 사용한다. 

- Mana 와 MaxMana 를 추가한다.
```c++
// SW_AttributeSet.h
#pragma once

#include "CoreMinimal.h"
#include "AttributeSet.h"
#include "SW_AttributeSet.generated.h"

UCLASS()
class TEAM4_CH4_PROJECT_API USW_AttributeSet : public UAttributeSet
{
	GENERATED_BODY()
public:
	USW_AttributeSet();

	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_Health, Category = "Vital Attributes")
	FGameplayAttributeData Health;

	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MaxHealth, Category = "Vital Attributes")
	FGameplayAttributeData MaxHealth;

	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_Mana, Category = "Vital Attributes")
	FGameplayAttributeData Mana;

	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MaxMana, Category = "Vital Attributes")
	FGameplayAttributeData MaxMana;

	UFUNCTION()
	void OnRep_Health(const FGameplayAttributeData& Old_Health) const;

	UFUNCTION()
	void OnRep_MaxHealth(const FGameplayAttributeData& Old_MaxHealth) const;

	UFUNCTION()
	void OnRep_Mana(const FGameplayAttributeData& Old_Mana) const;

	UFUNCTION()
	void OnRep_MaxMana(const FGameplayAttributeData& Old_MaxMana) const;

	virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;
};
```

```c++
// SW_Attribute.cpp
#include "SW_AttributeSet.h"
#include "AbilitySystemComponent.h"
#include "Net/UnrealNetwork.h"

USW_AttributeSet::USW_AttributeSet() { }

void USW_AttributeSet::OnRep_Health(const FGameplayAttributeData& Old_Health) const
{
	GAMEPLAYATTRIBUTE_REPNOTIFY(USW_AttributeSet, Health, Old_Health);
}

void USW_AttributeSet::OnRep_MaxHealth(const FGameplayAttributeData& Old_MaxHealth) const
{
	GAMEPLAYATTRIBUTE_REPNOTIFY(USW_AttributeSet, MaxHealth, Old_MaxHealth);
}

void USW_AttributeSet::OnRep_Mana(const FGameplayAttributeData& Old_Mana) const
{
	GAMEPLAYATTRIBUTE_REPNOTIFY(USW_AttributeSet, Mana, Old_Mana);
}

void USW_AttributeSet::OnRep_MaxMana(const FGameplayAttributeData& Old_MaxMana) const
{
	GAMEPLAYATTRIBUTE_REPNOTIFY(USW_AttributeSet, MaxMana, Old_MaxMana);
}

void USW_AttributeSet::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);

	DOREPLIFETIME_CONDITION_NOTIFY(USW_AttributeSet, Health, COND_None, REPNOTIFY_Always);
	DOREPLIFETIME_CONDITION_NOTIFY(USW_AttributeSet, MaxHealth, COND_None, REPNOTIFY_Always);
	DOREPLIFETIME_CONDITION_NOTIFY(USW_AttributeSet, Mana, COND_None, REPNOTIFY_Always);
	DOREPLIFETIME_CONDITION_NOTIFY(USW_AttributeSet, MaxMana, COND_None, REPNOTIFY_Always);
}
```

# Access Attribute Directly

AttributeSet.h 에 다음과 같은 주석문을 볼 수 있다.
```c++
// AttributeSet.h

/**
 * This defines a set of helper functions for accessing and initializing attributes, to avoid having to manually write these functions.
 * It would creates the following functions, for attribute Health
 *
 *	static FGameplayAttribute UMyHealthSet::GetHealthAttribute();
 *	FORCEINLINE float UMyHealthSet::GetHealth() const;
 *	FORCEINLINE void UMyHealthSet::SetHealth(float NewVal);
 *	FORCEINLINE void UMyHealthSet::InitHealth(float NewVal);
 *
 * To use this in your game you can define something like this, and then add game-specific functions as necessary:
 * 
 *	#define ATTRIBUTE_ACCESSORS(ClassName, PropertyName) \
 *	GAMEPLAYATTRIBUTE_PROPERTY_GETTER(ClassName, PropertyName) \
 *	GAMEPLAYATTRIBUTE_VALUE_GETTER(PropertyName) \
 *	GAMEPLAYATTRIBUTE_VALUE_SETTER(PropertyName) \
 *	GAMEPLAYATTRIBUTE_VALUE_INITTER(PropertyName)
 * 
 *	ATTRIBUTE_ACCESSORS(UMyHealthSet, Health)
 */
 
#define GAMEPLAYATTRIBUTE_PROPERTY_GETTER(ClassName, PropertyName) \
	static FGameplayAttribute Get##PropertyName##Attribute() \
	{ \
		static FProperty* Prop = FindFieldChecked<FProperty>(ClassName::StaticClass(), GET_MEMBER_NAME_CHECKED(ClassName, PropertyName)); \
		return Prop; \
	}
```
GAMEPLAYATTRIBUTE_PROPERTY_GETTER() 매크로를 선언하면 입력한 ClassName 과 PropertyName 으로 함수를 만들어 준다.
GetHealth() 는 Health 의  수치 값을 반환하고, GetHealthAttribute()는 FGameplayAttributeData 객체를 반환한다.
SetHealth() 는 Base 값만 설정하고, InitHealth() 는 Base, Current 값 둘 다 동일한 값으로 설정한다.
ATTRIBUTE_ACCESSORS 는 나머지 4개의 함수를 생성한다.

- 적용
```c++
// SW_AttributeSet.h

...
#include "AbilitySystemComponent.h"
#include "SW_AttributeSet.generated.h"

#define ATTRIBUTE_ACCESSORS(ClassName, PropertyName) \
	GAMEPLAYATTRIBUTE_PROPERTY_GETTER(ClassName, PropertyName) \
	GAMEPLAYATTRIBUTE_VALUE_GETTER(PropertyName) \
	GAMEPLAYATTRIBUTE_VALUE_SETTER(PropertyName) \
	GAMEPLAYATTRIBUTE_VALUE_INITTER(PropertyName)

UCLASS()
class TEAM4_CH4_PROJECT_API USW_AttributeSet : public UAttributeSet
{
	GENERATED_BODY()
public:
	USW_AttributeSet();

	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_Health, Category = "Vital Attributes")
	FGameplayAttributeData Health;

	GAMEPLAYATTRIBUTE_PROPERTY_GETTER(USW_AttributeSet, Health);

	...
```

```c++
// SW_AttributeSet.cpp
USW_AttributeSet::USW_AttributeSet()
{
	InitHealth(100.f);
}
```
Health 와 같은 방식으로 MaxHealth, Mana, MaxMana 변수를 추가한다.

- Show debug about Attribute
언리얼 에디터에서 console 입력으로 showdebug abilitysystem 입력. 다음과 같은 정보를 볼 수 있다.
![[Pasted image 20250409003233.png]]

# Effect Actor

AttributeSet 의 Attribute 를 변경하기 위한 Actor 를 만든다.

```c++
// SW_EffectActor.h
#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "SW_EffectActor.generated.h"

class USphereComponent;

UCLASS()
class TEAM4_CH4_PROJECT_API ASW_EffectActor : public AActor
{
	GENERATED_BODY()
	
public:	
	ASW_EffectActor();

protected:
	virtual void BeginPlay() override;

	UFUNCTION()
	virtual void OnOverlap(
		UPrimitiveComponent* OverlappedComponent,
		AActor* OtherActor,
		UPrimitiveComponent* OtherComp,
		int32 OtherBodyIndex,
		bool bFromSweep,
		const FHitResult& SweepResult
	);

	UFUNCTION()
	virtual void EndOverlap(
		UPrimitiveComponent* OverlappedComponent,
		AActor* OtherActor,
		UPrimitiveComponent*
		OtherComp,
		int32 OtherBodyIndex
	);
private:
	UPROPERTY(VisibleAnywhere)
	TObjectPtr<UStaticMeshComponent> Mesh;

	UPROPERTY(VisibleAnywhere)
	TObjectPtr<USphereComponent> Sphere;
};
```

```c++
// SW_EffectActor.cpp
#include "Actor/SW_EffectActor.h"
#include "Components/SphereComponent.h"
#include "AbilitySystemInterface.h"
#include "AbilitySystem/SW_AttributeSet.h"

ASW_EffectActor::ASW_EffectActor()
{
	PrimaryActorTick.bCanEverTick = false;
	Mesh = CreateDefaultSubobject<UStaticMeshComponent>("Mesh");
	SetRootComponent(Mesh);

	Sphere = CreateDefaultSubobject<USphereComponent>("Sphere");
	Sphere->SetupAttachment(GetRootComponent());
}

void ASW_EffectActor::BeginPlay()
{
	Super::BeginPlay();
	
	// bind ASW_EffectActor::OnOverlap to Sphere->OnComponentBeginOverlap
	Sphere->OnComponentBeginOverlap.AddDynamic(this, &ASW_EffectActor::OnOverlap);
	Sphere->OnComponentEndOverlap.AddDynamic(this, &ASW_EffectActor::EndOverlap);
}

// TODO : Change this to apply a Gameplay Effect. For now, using const_cast as a hack.
void ASW_EffectActor::OnOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)
{
	if (IAbilitySystemInterface* ASCInterface = Cast<IAbilitySystemInterface>(OtherActor))
	{
		const USW_AttributeSet* SW_AttributeSet = Cast<USW_AttributeSet>(ASCInterface->GetAbilitySystemComponent()->GetAttributeSet(USW_AttributeSet::StaticClass()));
		
		USW_AttributeSet* MutableAuraAttributeSet = const_cast<USW_AttributeSet*>(SW_AttributeSet);
		MutableAuraAttributeSet->SetHealth(SW_AttributeSet->GetHealth() + 25.f);
		Destroy();
	}
}

void ASW_EffectActor::EndOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{

}
```

AbilitySystemInterface 를 상속 받은 CharacterBase 에서 GetAbilitySystemComponent() 를 override 했기 때문에 충돌한 상대 Actor 를 AbilitySystemInterface 로 캐스팅 하여 AttributeSet 를 가져온다.
이때 Attribute Set 를 const 로 받게 되기 때문에 const_cost<> 를 사용하여 상수 포인터를 비상수 포인터로 변환한다. 비상수 포인터로 AttributeSet 에 접근하여 SetHeal() 을 호출한다.
앞으로 이러한 과정대신 Gameplay Effect 를 활용해서 변수값을 변경해야 한다.

Effect Actor 를 BP 로 만들고 Player 와 충돌했을때 Health 값이 변하는 것을 확인한다.

# Game UI

- UI 의 도메인
	1. View : 데이터의 시각적 효과 표시 (체력바, 능력 아이콘 등)
	2. Model (Data Itself) : 체력, 레벨, 마나, 경험치, 잠금 해제된 능력, 능력 레벨, 버튼 할당 등.
	3. Widget Controller : player controller 과 같이 폰을 소유 및 제어하는 클래스가 아니라 Model(Data) 를 View 에 전달하기 위한 클래스를 말한다. 뿐만 아니라 버튼과 같은 View 는 상호작용을 통해 Data 를 변경해야 하는데 이러한 상호작용을 처리(View 를 통한 사용자 입력 처리 및 해당 입력 처리를 Model 에 반영하는 신호로 전환.)하여 Model 에 변화를 발생시키는 것 또한 Widget Controller 가 진행한다. 즉, View 와 Model 사이의 중간자 역할이다. 

위의 구조는
- Model 이 어떤 WidgetController 나 View 가 자신의 데이터를 사용하는지 알 필요가 없다
- View 가 Widget Controller 에 의존.
- Widget Controller 가 Model 에 의존 하는 형식이다.
- Widget Controller 는 어떤 View 가 데이터를 받고 있는지 알 필요가 없다.
이러한 단방향 의존성을 유지하면 Model 은 Widget Controller 가 바뀌어도 코드를 변경할 필요가 없다. Widget Controller 또한 View 가 바뀌어도 코드 변경없이 재사용할 수 있다.

- Widget 기본 클래서 생성 -> UserWidget 를 상속 받은 SW_UserWidget
- UObject 를 상속 받은 SW_WidgetController c++ 클래스 생성
- Widget 이 WidgetController 라는 개념을 갖게한다. -> Widget Controller 가 데이터를 Broadcast 하면 Widget 은 그 데이터를 받아서 반응한다. (Widget-> Widget Controller 단방향이다. ; Widget Controller 는 어떤 Widget 과 연결되었는지 알지 못하지만, Widget 은 자신이 어떤 Widget controller 를 가지고 있는지 알고 있게 된다.)

- Widget Controller 와 Widget 의 Base 클래스 생성.
```c++
// SW_UserWidget.h

#pragma once

#include "CoreMinimal.h"
#include "Blueprint/UserWidget.h"
#include "SW_UserWidget.generated.h"

UCLASS()
class TEAM4_CH4_PROJECT_API USW_UserWidget : public UUserWidget
{
	GENERATED_BODY()

public:
	UFUNCTION(BlueprintCallable)
	void SetWidgetcontroller(UObject* InWidgetController);
	
public:
	UPROPERTY(BlueprintReadOnly)
	TObjectPtr<UObject> WidgetController;

protected:
	UFUNCTION(BlueprintImplementableEvent)
	void WidgetControllerSet();
};
```

```c++
// SW_UserWidget.cpp
#include "SW_UserWidget.h"

void USW_UserWidget::SetWidgetcontroller(UObject* InWidgetController)
{
	WidgetController = InWidgetController;
	WidgetControllerSet();
}
```

```c++
// SW_WidgetController.h
#pragma once

#include "CoreMinimal.h"
#include "UObject/NoExportTypes.h"
#include "SW_WidgetController.generated.h"

class UAttributeSet;
class UAbilitySystemComponent;

USTRUCT(BlueprintType)
struct FWidgetControllerParams
{
	GENERATED_BODY()

	FWidgetControllerParams() {};
	FWidgetControllerParams(APlayerController* PC, APlayerState* PS, UAbilitySystemComponent* ASC, UAttributeSet* AS)
		: PlayerController(PC), PlayerState(PS), AbilitySystemComponent(ASC), AttributeSet(AS) {
	};

public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	TObjectPtr<APlayerController> PlayerController = nullptr;

	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	TObjectPtr<APlayerState> PlayerState = nullptr;

	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	TObjectPtr<UAbilitySystemComponent> AbilitySystemComponent = nullptr;

	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	TObjectPtr<UAttributeSet> AttributeSet = nullptr;
};

UCLASS()
class TEAM4_CH4_PROJECT_API USW_WidgetController : public UObject
{
	GENERATED_BODY()
	
protected:
	UPROPERTY(BlueprintReadOnly, Category = "WidgetController")
	TObjectPtr<APlayerController> PlayerController;

	UPROPERTY(BlueprintReadOnly, Category = "WidgetController")
	TObjectPtr<APlayerState> PlayerState;

	UPROPERTY(BlueprintReadOnly, Category = "WidgetController")
	TObjectPtr<UAbilitySystemComponent> AbilitySystemComponent;

	UPROPERTY(BlueprintReadOnly, Category = "WidgetController")
	TObjectPtr<UAttributeSet> AttributeSet;

public:
	UFUNCTION(BlueprintCallable)
	void SetWidgetControllerParams(const FWidgetControllerParams& WCParams);
};
```

```c++
// SW_WidgetController.cpp
#include "SW_WidgetController.h"

void USW_WidgetController::SetWidgetControllerParams(const FWidgetControllerParams& WCParams)
{
	PlayerController = WCParams.PlayerController;
	PlayerState = WCParams.PlayerState;
	AbilitySystemComponent = WCParams.AbilitySystemComponent;
	AttributeSet = WCParams.AttributeSet;
}
```
### HUD

- HUD 상속 -> name SW_HUD 생성
```c++
// SW_HUD.h
#pragma once

#include "CoreMinimal.h"
#include "GameFramework/HUD.h"
#include "SW_HUD.generated.h"

class USW_OverlayWidgetController;
class UAbilitySystemComponent;
class UAttributeSet;
class USW_UserWidget;
struct FWidgetControllerParams;

UCLASS()
class TEAM4_CH4_PROJECT_API ASW_HUD : public AHUD
{
	GENERATED_BODY()
public:
	UPROPERTY()
	TObjectPtr<USW_UserWidget> OverlayWidget;

	USW_OverlayWidgetController* GetOverlayWidgetController(const FWidgetControllerParams& WCParams);

	void InitOverlay(APlayerController* PC, APlayerState* PS, UAbilitySystemComponent* ASC, UAttributeSet* AS);

private:
	UPROPERTY()
	TObjectPtr<USW_OverlayWidgetController> OverlayWidgetController;

	UPROPERTY(EditAnywhere)
	TSubclassOf<USW_UserWidget> OverlayWidgetClass;

	UPROPERTY(EditAnywhere)
	TSubclassOf<USW_OverlayWidgetController> OverlayWidgetControllerClass;
};
```

```c++
// SW_HUD.cpp
#include "UI/HUD_SJE/SW_HUD.h"
#include "UI/Widget/SW_UserWidget.h"
#include "UI/Controller/SW_OverlayWidgetController.h"

USW_OverlayWidgetController* ASW_HUD::GetOverlayWidgetController(const FWidgetControllerParams& WCParams)
{
	if (OverlayWidgetController == nullptr)
	{
		OverlayWidgetController = NewObject<USW_OverlayWidgetController>(this, OverlayWidgetControllerClass);
		OverlayWidgetController->SetWidgetControllerParams(WCParams);
		return OverlayWidgetController;
	}
	return OverlayWidgetController;
}

void ASW_HUD::InitOverlay(APlayerController* PC, APlayerState* PS, UAbilitySystemComponent* ASC, UAttributeSet* AS)
{
	checkf(OverlayWidgetClass, TEXT("Overlay Widget Class uninitialized, please fill out"));
	checkf(OverlayWidgetControllerClass, TEXT("Overlay Widget Controller Class uninitialized, please fill out"));

	UUserWidget* Widget = CreateWidget<UUserWidget>(GetWorld(), OverlayWidgetClass);
	OverlayWidget = Cast<USW_UserWidget>(Widget);

	const FWidgetControllerParams WidgetControllerParams(PC, PS, ASC, AS);
	USW_OverlayWidgetController* WidgetController = GetOverlayWidgetController(WidgetControllerParams);

	OverlayWidget->SetWidgetController(WidgetController);
	Widget->AddToViewport();
}
```

- CharacterPlayer 의 InitAbilityActorInfo() 에서 PlayerState, AbilitySystemComponent, Attributeset 를 설정한 후의 부분에 PlayerController 가 있는지 확인하고 4 개가 다 있다면 Widget Controller 를 생성한다.
```c++
// SW_CharacterBase.cpp
void ASW_CharacterPlayer::InitAbilityActorInfo()
{
	...
	if (ASW_PlayerController* SW_PlayerController = Cast<ASW_PlayerController>(GetController()))
	{
		if (ASW_HUD* SW_HUD = Cast<ASW_HUD>(SW_PlayerController->GetHUD()))
		{
			SW_HUD->InitOverlay(SW_PlayerController, SW_PlayerState, AbilitySystemComponent, AttributeSet);
		}
	}
}
```
InitAbilityActorInfo() 함수는 로컬에서 제어하지 않는 캐릭터에서도 호출될 수 있기 때문에 nullptr 체크를 통해 PlayerController 가 유효한지 확인한다.

- HUD 의 OverlayUserWidget 에 설정할 Widget 생성.
	- SW_UserWidget 상속 -> Name SW_PlayerStatWidget
```c++
// SW_PlayerStatWidget.h
#pragma once

#include "CoreMinimal.h"
#include "UI/Widget/SW_UserWidget.h"
#include "SW_PlayerStatWidget.generated.h"

class UImage;
class UTextBlock;
class UProgressBar;
class UHorizontalBox;

UCLASS()
class TEAM4_CH4_PROJECT_API USW_PlayerStatWidget : public USW_UserWidget
{
	GENERATED_BODY()
protected:
	/* Under the left Vertical Box */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (BindWidget))
	UImage* PlayerThumbnail;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (BindWidget))
	UTextBlock* PlayerLevelText;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (BindWidget))
	UProgressBar* ExpBar;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (BindWidget))
	UHorizontalBox* DebuffHBox;

	/* Under the right Vertical Box */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (BindWidget))
	UHorizontalBox* LifeHBox;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (BindWidget))
	UTextBlock* ATText;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (BindWidget))
	UTextBlock* DFText;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (BindWidget))
	UTextBlock* AGIText;
};
```

- SW_PlayerStatWidget 을 상속 받아 WBP_PlayerStat 생성
![[Pasted image 20250410042553.png]]

- SW_UserWidget 상속 -> WBP_Overlay 생성
![[Pasted image 20250410085038.png]]
WBP_Overlay 는 화면에 보여진 여러 WBP 클래스를 관리한다.

- BP_HUD 의 OverlayWidgetClass 에 WBP_Overlay 설정. / OverlayWidgetControllerClass 에 SW_OverlayWidgetController 설정.

이제 ATText 와 DFText 를 물약을 먹어서 값을 변경시킨다.
# HUD 의 값 변경

- SW_AttributeSet 에 AT 아 DF 추가
```c++
// SW_AttributeSet.h
UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_AT, Category = "Vital Attributes")
FGameplayAttributeData AT;
ATTRIBUTE_ACCESSORS(USW_AttributeSet, AT);

UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_DF, Category = "Vital Attributes")
FGameplayAttributeData DF;
ATTRIBUTE_ACCESSORS(USW_AttributeSet, DF);

UFUNCTION()
void OnRep_AT(const FGameplayAttributeData& AT) const;

UFUNCTION()
void OnRep_DF(const FGameplayAttributeData& DF) const;
```

```c++
// SW_AttributeSet.cpp
void USW_AttributeSet::OnRep_AT(const FGameplayAttributeData& Old_AT) const
{
	GAMEPLAYATTRIBUTE_REPNOTIFY(USW_AttributeSet, AT, Old_AT);
}

void USW_AttributeSet::OnRep_DF(const FGameplayAttributeData& Old_DF) const
{
	GAMEPLAYATTRIBUTE_REPNOTIFY(USW_AttributeSet, DF, Old_DF);
}

void USW_AttributeSet::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
	...
	DOREPLIFETIME_CONDITION_NOTIFY(USW_AttributeSet, AT, COND_None, REPNOTIFY_Always);
	DOREPLIFETIME_CONDITION_NOTIFY(USW_AttributeSet, DF, COND_None, REPNOTIFY_Always);
}
```

- Widget 측에서는 Attribute 에 접근할 수 없다. 따라서 WidgetController 에서는 초기 값을 broadcast 하는 함수를 생성한다.

```c++
// SW_WidgetController.h
public:
	virtual void BroadcastInitialValue();

// SW_WidgetController.cpp
void USW_WidgetController::BroadcastInitialValue()
{

}
```
Widgetcontroller 는 기본 클래스이기 때문에 Overlay 클래스에서 구현한다.

- OverlayWidgetController 에서 AT 아 DF 를 Broadcast 하는 dynamic multicast delegate 를 생성한다.
- dynamic multicast delegate 를 사용하여 Blueprint 에서 해당 delegate 에 Event 를 할당할 수 있도록 한다. 이러면 여러 개의 WBP 가 해당 delegate 에 바인딩 하여 업데이트를 받을 수 있다.
```c++
// SW_OverlayWidgetController.h
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnATChangedSignature, float, NewAT);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnDFChangedSignature, float, NewDF);

public:
	UPROPERTY(BlueprintAssignable, Category = "GAS|Attributes")
	FOnATChangedSignature OnATChanged;

	UPROPERTY(BlueprintAssignable, Category = "GAS|Attributes")
	FOnDFChangedSignature OnDFChanged;
```

```c++
// SW_OverlayWidgetController.cpp
void USW_OverlayWidgetController::BroadcastInitialValue()
{
	const USW_AttributeSet* SW_AttributeSet = CastChecked<USW_AttributeSet>(AttributeSet);

	OnATChanged.Broadcast(SW_AttributeSet->GetAT());
	OnDFChanged.Broadcast(SW_AttributeSet->GetDF());
}
```
CastChecked 를 통해 SW_AttributeSet 이 유효한지 확인하고 유효한 SW_AttributeSet 으로부터 AT 와 DF 를 가져와 Broadcast 한다.
이것은 곧, AttributeSet 이 유효한 시점에 BroadcastInitialValue() 를 호출 해야 한다는 말이다.

```c++
void ASW_HUD::InitOverlay(APlayerController* PC, APlayerState* PS, UAbilitySystemComponent* ASC, UAttributeSet* AS)
{
	...
	const FWidgetControllerParams WidgetControllerParams(PC, PS, ASC, AS);
	USW_OverlayWidgetController* WidgetController = GetOverlayWidgetController(WidgetControllerParams);

	OverlayWidget->SetWidgetController(WidgetController);

	WidgetController->BroadcastInitialValue();

	Widget->AddToViewport();
}
```

InitOverlay 에서 SetWidgetController() 를 호출할 때 전달되는 SE_OverlayWidgetController 에 유효한 AttributeSet 이 포함되어 있다. 따라서 SetWidgetController () 호출 이후에 BroadcastInitialValue() 를 호출한다.

또한 SetWidgetController 단계에서 WidgetControllerSet() 를 호출하기 때문에 이를 블루프린트 상에서 구현해 준다.
- WBP_Overlay  에 설정된 Widget Controller 를 산하 Widget 들에 설정하여 공유한다.
![[Pasted image 20250410085117.png]]

### HUD 의 산하 Widget 의 controller 에 대한 접근

- SW_OverlayWidgetController 를 UCLASS(BlueprintType, Blueprintable)로 수정
- SW_OverlayWidgetController 를 상속 ->BP_OverlayWidgetController 생성.
- BP_HUD 의 Overlay Widget Controller Class 에 BP_OverlayWidgetController 생성.
- WBP_PlayerState 에서
	- Event WidgetControllerSet -> Cast to BP_OverlayWidgetController -> Assign OnATChanged -> Assign OnDFChanged
![[Pasted image 20250410091428.png]]
각 Delegate 호출에서 전달받을 인자를 변수로 승격한다.

### Delegate 로 AT, DF 값 변화

- SW_WidgetController.h
```c++
// SW_WidgetController.h
virtual void BindCallbacksToDependencies();
```

- SW_OverlayWidgetController.h
```c++
// SW_OverlayWidgetController.h
public:
	virtual void BindCallbacksToDependencies() override;

protected:
	void ATChanged(const FOnAttributeChangeData& Data) const;
	void DFChanged(const FOnAttributeChangeData& Data) const;
```

```c++
// SW_OverlayWidgetController.cpp
void USW_OverlayWidgetController::BindCallbacksToDependencies()
{
	const USW_AttributeSet* SW_AttributeSet = CastChecked<USW_AttributeSet>(AttributeSet);
	AbilitySystemComponent->GetGameplayAttributeValueChangeDelegate(SW_AttributeSet->GetATAttribute()).AddUObject(this, &USW_OverlayWidgetController::ATChanged);
	AbilitySystemComponent->GetGameplayAttributeValueChangeDelegate(SW_AttributeSet->GetDFAttribute()).AddUObject(this, &USW_OverlayWidgetController::DFChanged);
}

void USW_OverlayWidgetController::ATChanged(const FOnAttributeChangeData& Data) const
{
	OnATChanged.Broadcast(Data.NewValue);
}

void USW_OverlayWidgetController::DFChanged(const FOnAttributeChangeData& Data) const
{
	OnDFChanged.Broadcast(Data.NewValue);
}
```

```c++
// SW_HUD.cpp
USW_OverlayWidgetController* ASW_HUD::GetOverlayWidgetController(const FWidgetControllerParams& WCParams)
{
	if (OverlayWidgetController == nullptr)
	{
		...
		OverlayWidgetController->BindCallbacksToDependencies();
		return OverlayWidgetController;
	}
	...
}
```

- WBP_PlayerStat 의 AT 와 DF TEXT 변경
	- WBP_PlayerStat 에서 함수 추가. SetDF, SetAT
![[Pasted image 20250410094914.png]]

- USW_AttributeSet 에서 AT 와 DF 값 설정.
```c++
// USW_AttributeSet.cpp
USW_AttributeSet::USW_AttributeSet()
{
	...
	InitAT(456.f);
	InitDF(321.f);
}
```

- 처음 플레이시 초기값 적용
![[Pasted image 20250410095510.png]]

- SW_EffectActor 에서 AT, DF 수치 추가
```c++
// SW_EffectActor.cpp
void ASW_EffectActor::OnOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)
{
	if (IAbilitySystemInterface* ASCInterface = Cast<IAbilitySystemInterface>(OtherActor))
	{
		const USW_AttributeSet* SW_AttributeSet = Cast<USW_AttributeSet>(ASCInterface->GetAbilitySystemComponent()->GetAttributeSet(USW_AttributeSet::StaticClass()));
		
		USW_AttributeSet* MutableAuraAttributeSet = const_cast<USW_AttributeSet*>(SW_AttributeSet);
		MutableAuraAttributeSet->SetHealth(SW_AttributeSet->GetHealth() + 25.f);
		MutableAuraAttributeSet->SetAT(SW_AttributeSet->GetAT() + 50.f);
		MutableAuraAttributeSet->SetDF(SW_AttributeSet->GetDF() + 100.f);
		Destroy();
	}
}
```

- 생성된 EffectActor 와 충돌했을 때 수치 변경.
![[Pasted image 20250410095934.png]]
### Character 에 귀속된 Widget UI
- HP Bar 생성
	- SW_UserWidget 상속 -> name SW_HpBarWidget
	- SW_HpBarWidget 상속 -> 블루프린트 생성 -> name BP_HpBarWidget
```c++
// SW_HpBarWidget.h
#include "CoreMinimal.h"
#include "SW_UserWidget.h"
#include "Components/ProgressBar.h"
#include "SW_HPBarWidget.generated.h"

UCLASS()
class TEAM4_CH4_PROJECT_API USW_HPBarWidget : public USW_UserWidget
{
	GENERATED_BODY()
	
public:
	UFUNCTION(BlueprintCallable)
	void SetHealthPercent(float Percent);

protected:
	UPROPERTY(meta = (BindWidget))
	UProgressBar* HealthProgressBar;
};
```

- CharacterBase 에 HpBarWidget 추가 및 설정.
```c++
// SW_Characterbase.h
protected:
    UPROPERTY(EditDefaultsOnly, Category = "UI")
    TSubclassOf<class UUserWidget> HealthBarWidgetClass;

    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "UI")
    UWidgetComponent* HealthBarWidgetComp;
```

```c++
// SW_CharacterBase.cpp
ASW_CharacterBase::ASW_CharacterBase()
{
	...
	HealthBarWidgetComp = CreateDefaultSubobject<UWidgetComponent>(TEXT("HpBar"));
	HealthBarWidgetComp->SetupAttachment(GetMesh());
	HealthBarWidgetComp->SetWidgetSpace(EWidgetSpace::World);
	HealthBarWidgetComp->SetRelativeLocation(FVector(0.f, 0.f, 280.f));
}

void ASW_CharacterBase::BeginPlay()
{
    Super::BeginPlay();

    if (HealthBarWidgetClass)
    {
        UUserWidget* HealthBarWidget = CreateWidget<UUserWidget>(GetWorld(), HealthBarWidgetClass);
        if (HealthBarWidget)
        {
            HealthBarWidgetComp->SetWidget(HealthBarWidget);
            HealthBarWidgetComp->SetDrawSize(FVector2D(100.f, 20.f));
            HealthBarWidgetComp->SetUsingAbsoluteRotation(true);
            HealthBarWidgetComp->SetRelativeRotation(FRotator(180.f, 0.f, 0.f));
            HealthBarWidgetComp->SetCastShadow(false);
        }
    }
}
```

UserWidget 은 실제 UI 로직과 외형을 갖지만 월드 상에 띄우기 위해서는 Component 를 통해 캐릭터에 Attach 해야 한다.

# Gameplay Effect

- GamePlay Effect 란
	**Gameplay Effect(GE)**는 GAS(Gameplay Ability System)에서 **속성(Attribute)**, **게임플레이 태그(Gameplay Tags)**, **어빌리티(Abilities)** 등을 **데이터 기반으로 조작**하기 위한 핵심 도구이다.  
	GE는 **UGameplayEffect 클래스**를 기반으로 하며, **로직 없이 오직 데이터만 포함**한다.

- Gameplay Effect 의 주요 역할
	- **속성 변경**: 체력, 마나 같은 수치를 변화시킬 수 있다.
	- **게임플레이 태그 조작**: 상태나 조건을 나타내는 태그를 추가하거나 제거할 수 있다
	- **어빌리티 부여**: 새로운 능력을 부여하거나 제거할 수 있다.
	- **중첩(Stacking)**: 동일한 GE가 여러 번 적용될 때의 처리 방식을 정의할 수 있다.
	- **지속 시간 정책(Duration Policy)**:
	    - `Instant`: 즉시 한 번만 적용되고 종료
	    - `Duration`: 일정 시간 동안 유지되며 시간이 지나면 사라짐
	    - `Infinite`: 영구적으로 적용되며 수동으로 제거해야 사라짐

- Attribute 변경 방식
	- Modifier (속성 변경의 기본 단위)
	- **Operation 종류**:
		- `Add`: 속성에 Magnitude 값을 더함 (음수로 설정하면 감산 효과)
		- `Multiply`: 속성 값을 배수로 곱함
		- `Divide`: 속성 값을 나눔
		- `Override`: 기존 값을 무시하고 Magnitude 값으로 덮어씀
	- **Magnitude 계산 방식**:
	    - `Scalable Float`: 고정값 또는 레벨 기반 테이블을 사용해 조절 가능한 수치
	    - `Attribute Based`: 다른 속성 값을 기반으로 계산 (예: Strength × 10만큼 Health 증가)
	    - `Custom Calculation Class`: 복잡한 조건이나 연산이 필요할 경우 직접 만든 클래스에서 계산
	    - `SetByCaller`: 코드에서 실시간으로 전달된 값으로 설정하는 방식 (Key-Value 형태, 주로 GameplayTag를 사용함)

- Execution
	- **Custom Execution (Execution Calculation, Exec Calc)**:
		- Modifier보다 더 복잡한 로직을 수행할 수 있음
		- **여러 속성을 동시에 변경**하거나, **커스텀 게임 로직 실행**도 가능함
		- Modifier는 하나의 속성만 바꾸지만, Execution은 복수 속성이나 외부 데이터까지 다룰 수 있음

- ETC
	- **GE는 하위 클래스를 따로 만들지 않음**.  
		커스텀 로직이 필요할 경우엔 **Execution이나 Magnitude Calculation 클래스**를 따로 만들어 연결함.
	- **Gameplay Effect Spec**:
	    - 경량화된 형태의 GE로, 실제 GE를 적용할 때 사용하는 임시 사본 같은 개념
	    - GE의 레벨, 태그, 컨텍스트(시전자, 대상자 등 정보 포함)를 담고 있음
	    - 실제 인스턴스는 대부분 Class Default Object(CDO)만 생성됨

- Gameplay Effect 는 
	- UGameplayEffect 타입 객체로 Attribute 와 GameplayTags 를 변경한다.
	- 로직 없이 오직 데이터만을 포함한다.
	- Modifier 와 Execution 을 통해 속성을 변경한다.
		- modifier 는 방식이 다양하다. 속성변경이 복잡하고 게임플레이에 특화되어야 할 경우를 위한 커스텀 계산도 지원한다.
		- Design Modifier 는 어떤 operation 을 Attribute 에 적용할 것인지를 명시한다.
		- Modifier 는 Magnitude 라는 값을 사용하고 이 값을 operation 을 통해 attribute 를 변경한다.
	- operation 에는 Add, Multiply, Divide, Override 가 있다.
		- Override 는 속성 값을 Magnitude 값으로 완전히 덮어씌우는 것을 말한다.
	- 계산 방식
		- Scalable float : 가장 단순한 수정 방식, Magnitude 값을 직접 지정할 수도 있고 Effect 의 레벨에 따라 값을 조절하는 테이블을 사용할 수도 있다.
		- Attribute Based : 다른 attribute 값을 사용한다. 예를 들어, 플레이어의 strength  만큼 health 를 증가시키는 식이다. 
		- Custom Calculation class : 원하는 Attribute 나 변수를 수집하고, 이를 기반으로 복잡한 계산을 수행하는 클래스를 만들 수 있다.
	- SetByCaller Magnitude 를 사용하여 Magnitude 설정.
		- key - value pair 로 되어있다. 이름이나 GameplayTag 에 연결된 Magnitude 값을 지정하는 방식이다.
		- 해당 방식은 Gameplay Effect 를 생성하거나 적용할 때, 코드 로직에 따라 Magnitude 값을 설정해야 할 경우 유용하다.
	- Custom Execution 을 활용한 Attribute 변경
		- 하나 이상의 attribute 를 변경하며 어떻게 코드하느냐에 따라 동작 수행이 다르다.
	- Duration Policy
		- Effect 는 즉시 단발성으로 적용되는 효과일 수도 있고 지속 시간이 있는 효과(일정 시간 동안 Attribute을 변경하고 시간이 지나면 변경이 취소)일 수 도 있다. 또는 무한 지속 효과(attribute 에 영향을 주고 수동으로 제거할 때까지 그 효과는 사라지지 않는다.)일 수 있다. 
	- Gameplay Effects 는 중첩(stack) 이 가능하며, stack 방식에 대한 정책을 갖는다.
	- Gameplay Tags 를 추가할 수도 있다.
	- Ability 를 부여할 수 도 있다.
	- Gameplay Effect 를 직접 적용할 수도 있지만 보통은 가벼운 버전인 Gameplay Effect Spec 을 생성한다.
	- Spec 은 수정 작업을 수행하는데 필요한 최소한의 정보를 담는다.
	- 일반적으로 생성되는 Gameplay Effect 클래스의 유일한 인스턴스는 class default object 이다.
	- Gameplay Effect 클래스는 하위 클래스로 상속하지 않고 커스텀 실행이나 magnitude 계산을 사용한다.

### EffectActor  변경

- Effect Actor 의 기존 구조를 지우고 Gameplay Eff
- ect 추가.

```c++
// SW_EffectActor
public:	
	ASW_EffectActor();

protected:
	virtual void BeginPlay() override;

	UFUNCTION(BlueprintCallable)
	void ApplyEffectToTarget(AActor* Target, TSubclassOf<UGameplayEffect> GameplayEffectClass);

	UPROPERTY(EditAnywhere, Category = "Applied Effects")
	TSubclassOf<UGameplayEffect> InstantGameplayEffectClass;
```

- ACS 를 가져오는 두 가지 방식 

1. 직접 IAbilitySystemInterface 로의 cast 후 GetAbilitySystemComponent()호출
``` c++
// SW_EffectActor.cpp
void ASW_EffectActor::ApplyEffectToTarget(AActor* Target, TSubclassOf<UGameplayEffect> GameplayEffectClass)
{
	IAbilitySystemInterface* ASCInterface = Cast<IAbilitySystemInterface>(Target);
	if (ASCInterface)
	{
		ASCInterface->GetAbilitySystemComponent();
	}
}
```

2. UAbilitySystemBlueprintLibrary 사용.
```c++
// SW_EffectActor.cpp
void ASW_EffectActor::ApplyEffectToTarget(AActor* Target, TSubclassOf<UGameplayEffect> GameplayEffectClass)
{
	UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(Target);
}
```
UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent 는 인자로 전달받는 Actor 가 UAbilitySystemInterface 를 상속 받았다면 UAbilitySystemInterface 로 캐스팅하여 GetAbilitySystemComponent() 를 호출하고 상속 받지 않았다면 FindComponentByClass 로 UAbilitySystemComponent 를 찾는다.

모든 액터를 철저하게 Interface 상속 구조로 만들것이라면 cast 와  GetAbilitySystemComponent 를 직접 사용하고 아니라면 UAbilitySystemBlurprintLibrary 를 사용한다.

해당 과정으로 얻은 AbilitySystemComponent 를 통해 MakeEffectcontext() 호출한다. MakeEffectcontext 는 Effect Context 를 생성하고 FGameplayEffectContextHandle 을 반환한다.
(FGameplayEffectContextHandle 은 FGameplayEffectContext 와 그 하위 클래스를 wrap 한 구조체이다. 이를 통해 다형성를 가지면서 네트워크 복제도 제대로 동작한다. FGameplayEffectContext 를 TSharedPtr 로 관리하는 DATA 라는 변수에 여러 간단한 기능을 구현한 것이다.)

- FGameplayEffectContext 는 무엇인가
GAS 안에서 Effect 가 발생한 맥락(context) 정보를 담는 구조체이다.
주요 변수들로 다음을 가지고 있다.

| name                             | description                                   |
| -------------------------------- | --------------------------------------------- |
| Instigator                       | 이 효과를 유발한 **주체(Instigator)**. 보통 캐릭터 자신       |
| EffectCauser                     | 실제로 데미지를 준 **무기나 발사체**                        |
| AbilityCDO                       | 이 효과를 만든 **어빌리티의 CDO (클래스 기본 객체)**            |
| AbilityInstanceNotReplicated     | 현재 실행 중인 **어빌리티 인스턴스 (복제 X)**                 |
| AbilityLevel                     | 이 효과가 발동된 **어빌리티의 레벨** (예: Fireball Lv3)      |
| SourceObject                     | 효과를 만든 **원천 오브젝트**, 예: 무기 아이템, 오라, 포션 등       |
| InstigatorAbilitySystemComponent | Instigator가 가진 ASC (Ability System Component) |
| Actors                           | 이 컨텍스트가 참조하는 추가 **연관 액터들**                    |
| HitResult                        | 피격 정보 (어디 맞았는지 등). 대부분의 경우 `nullptr`일 수도 있음   |
| WorldOrigin                      | 효과가 발생한 **월드 상의 위치**                          |
| bHasWorldOrigin                  | `WorldOrigin`이 유효한지 여부                        |
| bReplicateSourceObject           | `SourceObject`를 **복제할지 여부** (이 값 자체는 복제되지 않음) |
| bReplicateInstigator             | `Instigator`를 **복제할지 여부**                     |
| bReplicateEffectCauser           | `EffectCauser`를 **복제할지 여부**                   |
예를 들어 플레이어가 Fireball Ability  몬스터를 맞출 경우
- Instigator: 플레이어 캐릭터
- Causer: 발사된 Fireball 액터
- Ability: UGA_Fireball (파이어볼 어빌리티)
- SourceObject: 장착된 스태프 아이템
- HitResult: 몬스터의 머리를 맞춤
- WorldOrigin: 플레이어 위치

EffectContext 를 상속 하는 것으로 커스텀 할 수 있다.

```c++
// SW_EffectActor.cpp
void ASW_EffectActor::ApplyEffectToTarget(AActor* Target, TSubclassOf<UGameplayEffect> GameplayEffectClass)
{
	UAbilitySystemComponent* TargetASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(Target);

	FGameplayEffectContextHandle EffectContextHandle = TargetASC->MakeEffectContext();
	EffectContextHandle.AddSourceObject(this);
	FGameplayEffectSpecHandle EffectSpecHandle = TargetASC->MakeOutgoingSpec(GameplayEffectClass, 1.f, EffectContextHandle);
	TargetASC->ApplyGameplayEffectSpecToSelf(*EffectSpecHandle.Data.Get());
}
```
1. AbilitySystemBlueprintLibrary:: GetAbilitySystemComponent 를 사용하여 AbilitySystemComponent 를 갖는다.
2. ASC로 MakeEffectContext 를 호출하여 EffectContext 를 생성한다.
3. EffectContext 의 SourceObject 에 해당 클래스를 설정한다.
4. ASC 로 MakeOutfoingSpec 를 호출하여 FGameplayEffectSpec을 생성한다.
5. ASC 로 ApplyGameplayEffectSpecToSelf() 를 호출하여 스스로에게 GameplayEffect 를 적용시킨다. (최종 실행 역할)

FGameplayEffectSpec는 GameplayEffect, Level, EffectContext 등의 정보를 갖는다.

GameplayEffect 적용 함수 비교
- ApplyGameplayEffectToSelf
	- AbilitySystemComponent->ApplyGameplayEffectToSelf(FireEffect, 1.f, Context); // GameplayEffect 클래스만 전달하면 된다. Context 만 넣으면 되지만 SetByCaller, Custom Data 같은 것은 불가능 하다.
	- 간단한 자기 강화 효과 같은데에 쓰인다.
- ApplyGameplayEffectToTarget
- ApplyGameplayEffectSpecToSelf
	- 미리만든 spec 을 자기 자신에게 적용. 커스텀 `Context`, `SetByCaller`, `Tags`, `Level` 등 조절 가능
- ApplyGameplayEffectSpecToTarget

GameplayEffect 를 상속 받은 GE_PotionHeal 을 추가.

